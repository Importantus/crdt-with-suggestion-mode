/**
 * A annotation log to store annotations and comments. Used by CTrackChanges.
 * Derived from https://github.com/composablesys/collabs/blob/master/crdts/src/list/c_span_log.ts
 */

import {
  CollabEvent,
  CollabEventsRecord,
  CRDTMessageMeta,
  CRDTSavedStateMeta,
  DefaultSerializer,
  InitToken,
  MessageMeta,
  Position,
  PrimitiveCRDT,
  SavedStateMeta,
  Serializer,
} from "@collabs/collabs";
import { v4 as uuidv4 } from "uuid";

/**
 * A unique identifier for a annotation.
 */
export type AnnotationId = string;

/**
 * Type of a annotation.
 */
export enum AnnotationType {
  /** A annotation that adds a textual comment to a range of text. */
  COMMENT = "comment",
  /** A annotation that proposes an insertion or deletion of text within a given range. */
  SUGGESTION = "suggestion",
}

/**
 * Specifies whether the annotation represents an addition or a removal of a mark.
 *
 * An addition introduces a new mark, for example, adding a comment (`ADD_COMMENT`)
 * or proposing a deletion (`DELETE_SUGGESTION`).
 *
 * A removal resolves an existing mark, for example, removing a comment (`REMOVE_COMMENT`)
 * or accepting a annotation (`ACCEPT_SUGGESTION`).
 */
export enum AnnotationAction {
  ADDITION = "addition",
  REMOVAL = "removal",
}

/**
 * The more detailed description of what the annotation does.
 */
export enum AnnotationDescription {
  /** Adds a text comment to the given range */
  ADD_COMMENT = "addComment",
  /** Removes a text comment from the given range */
  REMOVE_COMMENT = "removeComment",
  /** Marks the given range as a annotation to insert text into the final document. */
  INSERT_SUGGESTION = "insertSuggestion",
  /** Marks the given range as a suggestion to delete text from the final document. */
  DELETE_SUGGESTION = "deleteSuggestion",
  /** Marks the text in the given range as an accepted suggestion, e.g., the text becomes part of the main document. */
  ACCEPT_SUGGESTION = "acceptSuggestion",
  /** Marks the text in the given range as a declined suggestion, e.g., the proposed change is discarded. */
  DECLINE_SUGGESTION = "declineSuggestion",
}

export interface PartialAnnotation {
  /**
   * A unique identifier for the annotation.
   * This is generated by the client that created the annotation.
   */
  readonly id: AnnotationId;
  /** The type of the annotation, specifying whether it concerns a comment or a textual change. */
  readonly type: AnnotationType;
  /** The action of the annotation, i.e. if it inserts or removes a annotation or comment */
  readonly action: AnnotationAction;
  /** The specific description of the annotation's purpose. */
  readonly description: AnnotationDescription;
  /** The value of the annotation. For comments, this holds the comment text. For other types, it is typically `undefined`. */
  readonly value?: string | undefined;
  /** The id of the user account that created the annotation */
  readonly userId: string;
  /** The start of the text range this annotation applies to. */
  readonly startPosition: Position;
  /** The end of the text range this annotation applies to, or `null` for the end of the document. */
  readonly endPosition: Position | null;
  /** Determines the behavior of insertions at the `endPosition`. If `true`, an insertion at the end position is considered part of the annotation's range. */
  readonly endClosed: boolean;
  /**
   * When the annotation is dependent on another annotation, then this is the id of the other annotation.
   * e.g. annotations of with the action "removal" are dependend of the corresponding "addition" annotation.
   */
  readonly dependentOn?: AnnotationId;
}

/**
 * A annotation is the building block of the track changes feature.
 * Each proposed change is modeled as a annotation that spans a range of text.
 * This can be an insertion of text, a comment, or the acceptance or decline of such a annotation.
 *
 * Each annotation is described by its type, its action, and a distinct description.
 */
export interface Annotation extends PartialAnnotation {
  /** The lamport timestamp of the action that inserted the annotation to determine a happened-before relationship */
  readonly lamport: number;
  /** The id of the sender that inserted the annotation. Used for lamport-tie-breaking */
  readonly senderID: string;
}

interface AnnotationLogSavedState {
  /** The ids of all senders (e.g. clients) that sent annotations */
  senderIds: string[];
  /** The number of annotations from each sender, corresponding to the `senderIds` array. Used to reconstruct the map. */
  lengths: number[];
  /** A flattened list of all annotations. */
  annotations: PartialAnnotation[];
  /** A flattened list of Lamport timestamps for each annotation. */
  lamports: number[];
}

/**
 * This event is emitted whenever a annotation is added to the log.
 * This can be triggered by a local operation or by a message from a remote replica.
 */
export interface AnnotationAddEvent extends CollabEvent {
  annotation: Annotation;
}

export interface AnnotationEventsRecord extends CollabEventsRecord {
  Add: AnnotationAddEvent;
}

/**
 * An append-only log of annotations and comments.
 * Intended for internal use by `CTrackChanges`.
 */
export class CAnnotationLog extends PrimitiveCRDT<AnnotationEventsRecord> {
  /**
   * A log of all received annotations, grouped by `senderID`.
   * This is the primary state of the CRDT and is used for saving its state.
   */
  private readonly log = new Map<string, Annotation[]>();

  private readonly partialAnnotationSerializer: Serializer<PartialAnnotation> =
    DefaultSerializer.getInstance<PartialAnnotation>();
  private readonly savedStateSerializer: Serializer<AnnotationLogSavedState> =
    DefaultSerializer.getInstance<AnnotationLogSavedState>();

  constructor(init: InitToken) {
    super(init);
  }

  /**
   * Adds a new annotation to the log.
   * This operation is broadcast to all replicas.
   * @param annotation The annotation to add.
   */
  add(annotation: Omit<PartialAnnotation, "id">): void {
    console.log("Adding annotation", annotation);
    super.sendCRDT(
      this.partialAnnotationSerializer.serialize({
        ...annotation,
        id: uuidv4(),
      })
    );
  }

  protected override receiveCRDT(
    message: Uint8Array | string,
    meta: MessageMeta,
    crdtMeta: CRDTMessageMeta
  ): void {
    const decoded = this.partialAnnotationSerializer.deserialize(
      message as Uint8Array
    );

    const annotation: Annotation = {
      ...decoded,
      lamport: getOrThrow(crdtMeta.lamportTimestamp),
      senderID: crdtMeta.senderID,
    };

    console.log("Received annotation", annotation);

    this.log.set(crdtMeta.senderID, [
      ...(this.log.get(crdtMeta.senderID) || []),
      annotation,
    ]);

    this.emit("Add", { annotation, meta });
  }

  protected override saveCRDT(): Uint8Array {
    const senderIDs = Array.from({ length: this.log.size });
    const lengths = Array.from({ length: this.log.size });
    const annotations: Annotation[] = [];
    const lamports: number[] = [];

    let i = 0;
    for (const [senderID, senderAnnotations] of this.log) {
      senderIDs[i] = senderID;
      lengths[i] = senderAnnotations.length;
      for (const annotation of senderAnnotations) {
        annotations.push(annotation);
        lamports.push(annotation.lamport);
      }
      i++;
    }

    return this.savedStateSerializer.serialize({
      senderIds: senderIDs,
      lengths,
      annotations,
      lamports,
    } as AnnotationLogSavedState);
  }

  protected override loadCRDT(
    savedState: Uint8Array | null,
    meta: SavedStateMeta,
    _: CRDTSavedStateMeta
  ): void {
    if (savedState === null) return;

    const decoded = this.savedStateSerializer.deserialize(savedState);
    let annotationIndex = 0;
    for (let i = 0; i < decoded.senderIds.length; i++) {
      const senderID = decoded.senderIds[i];
      let lastLamport: number;
      let bySender = this.log.get(senderID);
      if (bySender === undefined) {
        bySender = [];
        this.log.set(senderID, bySender);
        lastLamport = -1;
      } else {
        lastLamport = bySender[bySender.length - 1].lamport;
      }

      for (let j = 0; j < decoded.lengths[i]; j++) {
        const lamport = decoded.lamports[annotationIndex];
        if (lamport > lastLamport) {
          const annotation: Annotation = {
            ...decoded.annotations[annotationIndex],
            lamport,
            senderID,
          };
          bySender.push(annotation);

          this.emit("Add", { annotation, meta });
        }
        annotationIndex++;
      }
    }
  }
}

function getOrThrow(it: any) {
  if (it === null || it === undefined) {
    throw new Error("The requested value is null or undefined");
  } else {
    return it;
  }
}
